Download Link: https://assignmentchef.com/product/solved-cse-340-project-3
<br>
<strong>Abstract</strong>

The goal of this project is to give you some hands-on experience with implementing a small compiler. You will write a compiler for a simple language. You will not be generating assembly code. Instead, you will generate an intermediate representation (a data structure that represents the program). The execution of the program will be done after compilation by <em>interpreting </em>the generated intermediate representation.

<h1>1           Introduction</h1>

You will write a small compiler that will read an input program and represent in a linked list as a sequence of instruction. A node of the linked list represents one instruction. A instruction node specifies: (1) the type of the instructions, (2) the operand(s) of the instruction (if any) and, for jump instructions, the next instruction to be executed (the default is that the next instruction in the list is executed). After the list of instructions is generated by your compiler, your compiler will <em>execute </em>the generated list of instructions by interpreting it. This means that the program will traverse the data structure and at every node it visits, it will “execute” the node by changing the content of memory locations corresponding to operands and deciding what is the next instruction to execute (program counter). The output of your compiler is the output that the input program should produce. These steps are illustrated in the following figure

The remainder of this document is organized into the following sections:

<ol>

 <li><strong>Grammar </strong>Defines the programming language syntax including grammar.</li>

 <li><strong>Execution Semantics </strong>Describe statement semantics for assignment, input, if, while, switch, <em>for </em>and output</li>

 <li><strong>How to generate the linked list of instructions </strong>Explains step by step how to generate the intermediate representation (data structure). <strong>You should read this sequentially and not skip around.</strong></li>

 <li><strong>Requirements </strong>Lists other requirements.</li>

 <li><strong>Grading </strong>Describes the grading scheme.</li>

</ol>

<h1>2           Grammar</h1>

The grammar for this project is the following:

<table width="504">

 <tbody>

  <tr>

   <td width="91"><em>program</em></td>

   <td width="35">→</td>

   <td width="240"><em>var </em><em>section   body   inputs</em></td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>var section</em></td>

   <td width="35">→</td>

   <td width="240"><em>id </em><em>list </em>SEMICOLON</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>id </em><em>list</em></td>

   <td width="35">→</td>

   <td width="240">ID COMMA            <em>id </em><em>list </em>| ID</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>body</em></td>

   <td width="35">→</td>

   <td width="240">LBRACE         <em>stmt </em><em>list </em>RBRACE</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>stmt list</em></td>

   <td width="35">→</td>

   <td width="240"><em>stmt       stmt list </em>| stmt</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>stmt stmt</em></td>

   <td width="35">→→</td>

   <td width="240"><em>assign stmt </em>| <em>while stmt </em>| <em>if stmt </em>| <em>output stmt </em>| <em>input stmt</em></td>

   <td width="77"><em>switch </em><em>stmt</em></td>

   <td width="15">|</td>

   <td width="46"><em>for stmt</em></td>

  </tr>

  <tr>

   <td width="91"><em>assign stmt</em></td>

   <td width="35">→</td>

   <td width="240">ID EQUAL             <em>primary </em>SEMICOLON</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>assign stmt</em></td>

   <td width="35">→</td>

   <td width="240">ID EQUAL             <em>expr </em>SEMICOLON</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>expr</em></td>

   <td width="35">→</td>

   <td width="240"><em>primary    op    primary</em></td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>primary</em></td>

   <td width="35">→</td>

   <td width="240">ID | NUM</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>op</em></td>

   <td width="35">→</td>

   <td width="240">PLUS | MINUS | MULT | DIV</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

  <tr>

   <td width="91"><em>output stmt</em></td>

   <td width="35">→</td>

   <td width="240"><strong>output </strong>ID SEMICOLON</td>

   <td width="77"></td>

   <td width="15"></td>

   <td width="46"></td>

  </tr>

 </tbody>

</table>

<em>inputstmt    </em>→            <strong>input </strong>ID SEMICOLON <em>while stmt   </em>→       WHILE <em>condition body</em>

<table width="623">

 <tbody>

  <tr>

   <td width="91"><em>if stmt</em></td>

   <td width="35">→</td>

   <td width="404">IF <em>condition       body</em></td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>condition</em></td>

   <td width="35">→</td>

   <td width="404"><em>primary    relop    primary</em></td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>relop</em></td>

   <td width="35">→</td>

   <td width="404">GREATER | LESS | NOTEQUAL</td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>switch stmt</em></td>

   <td width="35">→</td>

   <td width="404">SWITCH ID                LBRACE <em>case list </em>RBRACE</td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>switch stmt</em></td>

   <td width="35">→</td>

   <td width="404">SWITCH ID            LBRACE <em>case list          default case </em>RBRACE</td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>for </em><em>stmt</em></td>

   <td width="35">→</td>

   <td width="404">FOR LPAREN assign stmt condition SEMICOLON assign stmt</td>

   <td width="68">RPAREN</td>

   <td width="25"><em>body</em></td>

  </tr>

  <tr>

   <td width="91"><em>case list</em></td>

   <td width="35">→</td>

   <td width="404"><em>case      case </em><em>list </em>| <em>case</em></td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>case</em></td>

   <td width="35">→</td>

   <td width="404">CASE NUM            COLON <em>body</em></td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>default </em><em>case</em></td>

   <td width="35">→</td>

   <td width="404">DEFAULT COLON           <em>body</em></td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>inputs</em></td>

   <td width="35">→</td>

   <td width="404"><em>num </em><em>list</em></td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>num list</em></td>

   <td width="35">→</td>

   <td width="404">NUM</td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

  <tr>

   <td width="91"><em>num list</em></td>

   <td width="35">→</td>

   <td width="404">NUM <em>num list</em></td>

   <td width="68"></td>

   <td width="25"></td>

  </tr>

 </tbody>

</table>

<strong>Some highlights of the grammar:</strong>

<ol>

 <li>Division is integer division and the result of the division of two integers is an integer.</li>

 <li>Note that <em>if stmt </em>does not have <em>else</em>.</li>

 <li>Note that <em>for </em>has a very general syntax similar to that of the <em>for loop </em>in the C language</li>

 <li>Note that the <strong>input </strong>and <strong>output </strong>keywords are lowercase, but other keywords are all uppercase.</li>

 <li><em>condition </em>has no parentheses.</li>

 <li>There is no type specified for variables. All variables are int by default.</li>

</ol>

<h1>3           Variables and Locations</h1>

The <em>var </em><em>section </em>contains a list of all variable names that can be used by the program. For each variable name, we associate a unique locations that will hold the value of the variable. This association between a variable name and its location is assumed to be implemented with a function location that takes a variable name (string) as input and returns an integer value. The locations where variables will be stored is called mem which is an array of integers. Each variable in the program should have a unique entry (index) in the mem array. This association between variable names and locations can be implemented with a location table.

As your parser parses the input program, it <em>allocates </em>locations to variables that are listed in the <em>var section</em>. You can assume that all variable names listed in the var section are unique. For each variable name, a new location needs to be associated with it and the mapping from the variable name to the location needs to be added to the location table. To associate a location with a variable, you can simply keep a counter that tells you how many locations have been used (associated to variable names). Initially the counter is 0. The first variable to be associated a location will get the location whose index is 0 (mem[0]) and the counter will be incremented to become 1. The next variable to be associated a location will get the location whose index is 1 and the counter will be incremented to become 2 and so on.

<h1>4           Inputs</h1>

The list of input values is called <em>inputs </em>and appears as the last section of an input program. This list must be read by your compiler and stored in an inputs array, which is simply a vector of integers.

<h1>5           Execution Semantics</h1>

All statements in a statement list are executed sequentially according to the order in which they appear. Exception is made for body of <em>if stmt</em>, <em>while </em><em>stmt </em>and <em>switch </em><em>stmt </em>as explained below. In what follows, I will assume that all values of variables as well as constants are stored in locations. This assumption is used by the execution procedure that we provide. This is not a restrictive assumption. For variables, you will have locations associated with them. For constants, you can reserve a location in which you store the constant (this is like having an unnamed immutable variable).

<strong>5.0.1        Input statements</strong>

Input statements get their input from the sequence of inputs. We refer to i’th value that appears in inputs as i’th input. The execution of the i’th input statement in the program of the form input a is equivalent to:

mem[location(“a”)] = inputs[input_index] input_index = input_index + 1

where location(“a”) is an integer index value that is calculated at compile time as we have seen above. Note that the execution of an input statement advances an input index which keeps track (at runtime) of the next value to read (like in project 1).

<h2>5.1         <em>Output </em>statement</h2>

The statement output a; prints the value of variable a at the time of the execution of the <em>output statement</em>.

<h2>5.2         Assignment Statement</h2>

To execute an assignment statement, the expression on the righthand side of the equal sign is evaluated and the result is stored in the location associated with the lefthand side of the expression.

<h2>5.3         Expression</h2>

To evaluate an expression, the values in the locations associated with the two operands are obtained and the expression operator is applied to these values resulting in a value for the expression.

<h2>5.4         Boolean Condition</h2>

A boolean condition takes two operands as parameters and returns a boolean value. It is used to control the execution of <em>while</em>, <em>if </em>and <em>for </em>statements. To evaluate a condition, the values in the locations associated with the operands are obtained and the relational operator is applied to these values resulting in a true or false value. For example, if the values of the two operands a and b are 3 and 4 respectively, a &lt; b evaluates to <strong>true</strong>.

<h2>5.5         <em>If </em>statement</h2>

<em>if </em><em>stmt </em>has the standard semantics:

<ol>

 <li>The condition is evaluated.</li>

 <li>If the condition evaluates to <strong>true</strong>, the body of the <em>if </em><em>stmt </em>is executed, then the next statement (if any) following the <em>if </em><em>stmt </em>in the <em>stmt </em><em>list </em>is executed.</li>

 <li>If the condition evaluates to <strong>false</strong>, the statement following the <em>if stmt </em>in the <em>stmt </em><em>list </em>is executed.</li>

</ol>

<h2>5.6         <em>While </em>statement</h2>

<em>while </em><em>stmt </em>has the standard semantics.

<ol>

 <li>The condition is evaluated.</li>

 <li>If the condition evaluates to <strong>true</strong>, the body of the <em>while </em><em>stmt </em>is executed. The next statement to execute is the <em>while stmt </em></li>

 <li>If the condition evaluates to <strong>false</strong>, the body of the <em>while </em><em>stmt </em>is not executed. The next statement to execute is the next statement (if any) following the <em>while stmt </em>in the <em>stmt list</em>.</li>

</ol>

The code block:

<table width="594">

 <tbody>

  <tr>

   <td width="594">WHILE <em>condition</em>{ <em>stmt list</em>}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594"><em>label</em>: IF <em>condition</em>{ <em>stmt list </em><strong>goto </strong><em>label</em>}</td>

  </tr>

 </tbody>

</table>

<strong>Jump</strong>. In the code above, a goto statement is similar to the goto statement in the C language. Note that <strong>goto </strong>statements are not part of the grammar and cannot appear in a program (input to your compiler), but our intermediate representation includes jump which is used in the implementation of <em>if</em>, <em>while</em>, <em>for</em>, and <em>switch </em>statements (jump is discussed later in this document).

<h2>5.7         <em>For </em>statement</h2>

The <em>for stmt </em>is very similar to the for statement in the C language. The semantics are defined by giving an equivalent construct.

<table width="594">

 <tbody>

  <tr>

   <td width="594">FOR ( <em>assign stmt 1 condition </em>; <em>assign stmt 2 </em>){ <em>stmt list</em>}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<em>assign stmt 1</em>

WHILE <em>condition</em>

{

<em>stmt list assign stmt 2 </em>}

For example, the following snippet of code:

<table width="594">

 <tbody>

  <tr>

   <td width="594">FOR ( a = 0; a &lt; 10; a = a + 1; ){ output a;}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594">a = 0;WHILE a &lt; 10{ output a;a = a + 1;}</td>

  </tr>

 </tbody>

</table>

<h2>5.8         <em>Switch </em>statement</h2>

<em>switch stmt </em>has the following semantics:

<ol>

 <li>The value of the switch variable is checked against each case number in order.</li>

 <li>If the value matches the number, the body of the case is executed, then the statement following the <em>switch </em><em>stmt </em>in the <em>stmt list </em>is executed.</li>

 <li>If the value does not match the number, the next case number is checked.</li>

 <li>If a default case is provided and the value does not match any of the case numbers, then the body of the default case is executed and then the statement following the <em>switch stmt </em>in the <em>stmt </em><em>list </em>is executed.</li>

 <li>If there is no default case and the value does not match any of the case numbers, then the statement following the <em>switch </em><em>stmt </em>in the <em>stmt </em><em>list </em>is executed.</li>

</ol>

The code block:

<table width="594">

 <tbody>

  <tr>

   <td width="594">SWITCH <em>var </em>{CASE <em>n</em><sub>1 </sub>: { <em>stmt list 1 </em>}…CASE <em>n<sub>k </sub></em>: { <em>stmt list </em><em>k </em>}}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594">IF <em>var </em>== <em>n</em><sub>1 </sub>{<em>stmt list </em><em>1 </em><strong>goto </strong><em>label</em>}…IF <em>var </em>== <em>n<sub>k </sub></em>{<em>stmt list </em><em>k </em><strong>goto </strong><em>label</em>}<em>label</em>:</td>

  </tr>

 </tbody>

</table>

And for switch statements with default case, the code block:

<table width="594">

 <tbody>

  <tr>

   <td width="594">SWITCH <em>var </em>{CASE <em>n</em><sub>1 </sub>: { <em>stmt list 1 </em>}…CASE <em>n<sub>k </sub></em>: { <em>stmt list </em><em>k </em>}DEFAULT : { <em>stmt list default </em>}}</td>

  </tr>

 </tbody>

</table>

is equivalent to:

<table width="594">

 <tbody>

  <tr>

   <td width="594">IF <em>var </em>== <em>n</em><sub>1 </sub>{<em>stmt list </em><em>1 </em><strong>goto </strong><em>label</em>}…IF <em>var </em>== <em>n<sub>k </sub></em>{<em>stmt list </em><em>k </em><strong>goto </strong><em>label</em>}<em>stmt list default</em><em>label</em>:</td>

  </tr>

 </tbody>

</table>

Note that the switch statement in the C language has different syntax and semantics. It is also dangerous!

<h1>6           How to generate the code</h1>

The intermediate code will be a data structure (a graph) that is easy to interpret and execute. I will start by describing how this graph looks for simple assignments then I will explain how to deal with <em>while </em>statements.

<strong>Note that in the explanation below I start with incomplete data structures then I explain what is missing and make them more complete. You should read the whole explanation.</strong>

<h2>6.1         Handling simple assignments</h2>

A simple assignment is fully determined by: the operator (if any), the id on the left-hand side, and the operand(s). A simple assignment can be represented as a node:

struct AssignmentInstruction { int left_hand_side_index; int operand1_index; int operand2_index;

ArithmeticOperatorType op; // operator }

For assignment without an operator on the right-hand side, the operator is set to OPERATOR NONE and there is only one operand. To execute an assignment, you need calculate the value of the righthand-side and assign it to the left-hand-side. If there is an operator, the value of the right-hand-side is calculated by applying the operator to the values of the operands. If there is no operator, the value of the right-hand-side is the value of the single operand: for literals (NUM), the value is the value of the number; for variables, the value is the last value stored in the location associated with the variable. <strong>Initially, all variables are initialized to 0</strong>. In this representation, the locations associated with variables as well as the locations in which constants are in the mem[] array mentioned above. In the statement, the index (address) of the location where the value of the variable or the constant is stored is given. The actual values in mem[] can be fetched or modified (for variables) at runtime.

Multiple assignments are executed one after another. So, we need to allow multiple assignment nodes to be linked to each other. This can be achieved as follows:

struct AssignmentInstruction { int left_hand_side_index; int operand1_index; int operand2_index;

ArithmeticOperatorType op; // operator struct AssignmentStatement* next;

}

This structure only accepts indices (addresses) as operands. To handle literal constants (NUM), you need to store their values in mem[] at compile time and use the index of the constant as the operant.

This data structure will now allow us to execute a sequence of assignment statements represented in a linked-list of assignment instructions: we start with the head of the list, then we execute every assignment in the list one after the other.

<strong>Begin Note </strong>It is important to distinguish between compile-time initialization and runtime execution. For example, consider the program

a, b;

{

a = 3; b = 5;

}

1 2 3 4

The intermediate representation for this program will have have two assignment instructions: one to copy the value in the location that contains the value 3 to the location associated with a and one to copy the value in the location that contains the value 5 to the location associated with b (also, your program should read the inputs and store them in the inputs vector, but this is not the point of this example). The values 3 and 5 will not be copied to the locations of a and b at compile-time. The values 3 and 5 will be copied during execution by the interpreter that we provided. I highly recommend that you read the code of the interpreter that we provided as well as the code in demo.cc. In demo.cc, a hardcoded data structure is shown for an example input program, which can be very useful in understanding what the data structure your program will generate will look like. <strong>End Note</strong>

This is simple enough, but does not help with executing other kinds of statements. We consider them one at a time.

<h2>6.2         Handling <em>output </em>statements</h2>

The <em>output </em>statement is straightforward. It can be represented as

struct OutputInstruction

{ int var_index;

}

where the operand is the index of the location of the variable to be printed.

Now, we ask: how can we execute a sequence of statements that are either <em>assign </em>or <em>output </em>statement (or other types of statements)? We need to put the instructions for both kinds of statements in a list. So, we introduce a new kind of node: an instruction node. The instruction node has a field that indicates which type of instruction it is. It also has fields to accommodate instructions for the remaining types of statements. It looks like this:

struct InstructionNode {

InstructionType type; // NOOP, ASSIGN, JMP, CJMP (conditional jump), IN, OUT

union { struct { int left_hand_side_index; int operand1_index; int operand2_index;

ArithmeticOperatorType op;

} assign_inst; struct {

// details below } jmp_inst; struct {

// details below } cjmp_inst; struct { int var_index; } input_inst ; struct { int var_index;

} output_inst;

}; struct InstructionNode* next;

}

This way we can go through a list of instructions and execute one after the other or, if an instruction is a jump instruction, execute the target of the jump after the instruction. To execute a particular instruction node, we check its type. Depending on its type, we can access the appropriate fields in one of the structures of the union. If the type is OUT (output), for example, we access the field var index in the output inst struct to execute the instruction. Similarly for the IN (input) instruction. if the type is ASSIGN, we access the appropriate fields in the assign inst struct to execute the instruction and so on.

With this combination of various instructions types in one struct, note how the next field is now part of the InstructionNode to line up all instructions in a sequence one after another.

This is all fine, but we do not yet know how to generate the list of instructions to execute later. The idea is to have the functions that parses non-terminals return the code that corresponds to the non-terminals, the code being a sequence of instructions. For example for a statement list, we have the following pseudocode (missing many checks):

struct InstructionNode* parse_stmt_list()

{ struct InstructionNode* inst; // instruction for one statement struct InstructionNode* instl; // instruction list for statement list

inst = parse_stmt(); if (nextToken == start of a statement list)

{ instl = parse_stmt_list();

append instl to inst; // this is pseudocode return inst;

}

else { ungetToken(); return inst;

}

}

And to parse <em>body </em>we have the following pseudocode:

struct InstructionNode* parse_body()

{ struct InstructionNode* instl;

match LBRACE instl = parse_stmt_list(); match RBRACE

return instl;

}

<h2>6.3         Handling <em>if </em>and <em>while </em>statements</h2>

More complications occur with <em>if </em>and <em>while </em>statements. These statements would need to be implemented using the conditional jump (CJMP) and the jump (JMP) instructions. The conditional jump struct would have the following fields

struct CJMP {

ConditionalOperatorType condition_op; int operand1_index; int operand2_index; struct InstructionNode * target;

}

The condition op, operand1 index and operand2 index fields are the operator and operands of the condition of the conditional jump (CJMP) instruction. The target field is the next instruction to execute if the condition evaluate to false. If the condition evaluates to true, the next instruction to execute will be the next instruction in the sequence of instructions.

To generate code for the <em>while </em>and <em>if </em>statements, we need to put a few things together. The outline given above for <em>stmt </em><em>list</em>, needs to be modified as follows (this is missing details and shows only the main steps):

struct InstructionNode* parse_stmt()

{ …

InstructionNode * inst = new InstructionNode; if next token is IF

{ inst-&gt;type = CJMP;

parse the condition and set inst-&gt;cjmp_inst.condition_op,

inst-&gt;cjmp_inst.operand1_index and inst-&gt;cjmp_inst.operand2_index

inst-&gt;next = parse_body();                                                                                      // parse_body returns a pointer to a sequence of instructions

create no-op node                                                                                                    // this is a node that does not result

// in any action being taken.

// make sure to set the next field to nullptr

append no-op node to the body of the if                                                      // this requires a loop to get to the end of

// true_branch by following the next field

// you know you reached the end when next is nullptr

// it is very important that you always appropriately

// initialize fields of any data structures // do not use uninitialized pointers

set inst-&gt;cjmp_inst.target to point to no-op node …

return inst;

} else …

}

The following diagram shows the desired structure for the <em>if </em>statement:

<strong>Sequence of instructions for body of if stmt</strong>

The <em>stmt list </em>code should be modified because the code presented above for a <em>stmt list </em>assumed that each statement is represented with one instruction but we have just seen that parsing an <em>if </em><em>list </em>returns a sequence of instructions. The modification is as follows:

struct InstructionNode* parse_stmt_list()

{ struct InstructionNode* instl1;             // instruction list for stmt struct InstructionNode* instl2; // instruction list for stmt list

instl1 = parse_stmt(); if (nextToken == start of a statement list)

{

instl2 = parse_stmt_list();

append instl2 to instl1

//                 instl1

//                  |

//           V //           .

//                  .

//                  .

//             last node in

//            sequence staring

//            with instl1

//                  |

//                 V

//               instl2

return instl1;

} else { ungetToken(); return instl1;

}

}

Handling <em>while </em>statement is similar. Here is the outline for parsing a <em>while </em>statement and creating the data structure for it:

…

create instruction node inst if next token is WHILE

{

inst-&gt;type = CJMP;                                                                                            // handling WHILE using if and goto nodes

parse the condition and set inst-&gt;cjmp_inst.condition_op, inst-&gt;cjmp_inst.operand1 and inst-&gt;cjmp_inst.condition_operand2

<table width="479">

 <tbody>

  <tr>

   <td width="242">inst-&gt;next = parse_body();</td>

   <td width="237">// when condition is true the next instruction// is the first instruction of the body of while</td>

  </tr>

  <tr>

   <td width="242">create jmp node of type JMP</td>

   <td width="237">// do not forget to set next field to nullptr</td>

  </tr>

 </tbody>

</table>

set jmp-&gt;jmp_inst.target to inst append jmp node to end of body of while

create no-op node and attach it to the list of instruction after the jmp node set inst-&gt;cjmp_target.target to point to no-op node return inst;

} …

The following diagram shows the desired structure for the <em>while </em>statement:

<strong>Sequence of instructions for body of while stmt</strong>

<h2>6.4         Handling <em>switch </em>and <em>for </em>statements</h2>

You can handle the <em>switch </em>and <em>for </em>statements similarly, but you should figure that yourself. Use a combination of JMP and CJMP to support the semantics of the <em>switch </em>and <em>for </em>statements. See sections 5.8 and 5.7 for the semantics of the <em>switch </em>and <em>for </em>statements.

<h1>7           Executing the intermediate representation</h1>

After the graph data structure is built, it needs to be executed. Execution starts with the first node in the list. Depending on the type of the node, the next node to execute is determined. The general form for execution is illustrated in the following pseudo-code.

pc = first node while (pc != nullptr)

{ switch (pc-&gt;type)

{

<table width="406">

 <tbody>

  <tr>

   <td width="102">case ASSIGN:</td>

   <td width="305">// code to execute pc-&gt;assign_stmt …pc = pc-&gt;next</td>

  </tr>

  <tr>

   <td width="102">case CJMP:</td>

   <td width="305">// code to evaluate condition …// depending on the result//                               pc = pc-&gt;cjmp_inst.target (if condition is false)</td>

  </tr>

 </tbody>

</table>

// or

//               pc = pc-&gt;next (if condition is true)

<table width="390">

 <tbody>

  <tr>

   <td width="102">case NOOP:</td>

   <td width="288">pc = pc-&gt;next</td>

  </tr>

  <tr>

   <td width="102">case JMP:</td>

   <td width="288">pc = pc-&gt;jmp_inst.target</td>

  </tr>

  <tr>

   <td width="102">case OUT:</td>

   <td width="288">// code to print mem[pc-&gt;output_inst.var_index] …pc = pc-&gt;next</td>

  </tr>

  <tr>

   <td width="102">case IN:</td>

   <td width="288">// code to read next input value into// mem[pc-&gt;input_inst.var_index] and updating // counter for how many values have been read pc = pc-&gt;next</td>

  </tr>

 </tbody>

</table>

}

}

We have provided you with the data structures and the code to execute the graph and <strong>you must use it. </strong>When you submit your code, you will not submit compiler.cc and compiler.h, we will provide them automatically for your submission, so if you modify them, your submission will not compile and run.. There are two files compiler.h and compiler.cc, you need to write your code in separate file(s) and #includecompiler.h. The entry point of your code is a function declared

in compiler.h: struct InstructionNode* parse_generate_intermediate_representation();

You need to implement this function. The main() function is provided in compiler.cc:

int main()

{ struct InstructionNode * program;

program = parse_generate_intermediate_representation(); execute_program(program); return 0;

}

It calls the function that you will implement which is supposed to parse the program and generate the intermediate representation, then it calls the execute program function to execute the program. You should not modify any of the given code. In fact, you should not submit compiler.cc and compiler.h; we will provide them when you submit your code.

<h1>8           Requirements</h1>

<ol>

 <li>Write a compiler that generates intermediate representation for the code. The interpreter (execute function) is provided.</li>

 <li><strong>Language: </strong>You can only use C++ for this assignment.</li>

 <li><strong>You can assume that there are no syntax or semantic errors in the input program.</strong></li>

</ol>